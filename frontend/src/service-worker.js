/// <reference lib="webworker" />
import { build, files, prerendered, version } from '$service-worker'

const CACHE_NAME = `cache-${version}`;
const EXCLUDED = [
	/^\/icons\//,
	/\/browserconfig.xml/,
	/\/app.webmanifest/
];

// Files generated by the bundler
const ASSETS = build
	// `static` directory contents
	.concat(files)
	// pre-rendered endpoints
	.concat(prerendered)
	// removing excluded contents
	.filter(path => !EXCLUDED.find(matcher => matcher.test(path)));

self.addEventListener('install', async () => {
	// Remove old caches
	for (const name of await caches.keys()) {
		await caches.delete(name);
	}

	const cache = await caches.open(CACHE_NAME);
	await cache.addAll(ASSETS);
	await self.skipWaiting();

	console.log('[SW] Installed');
});

/**
 * @param {Request} request
 * @returns {Promise<Response>}
 */
async function requestCached (request) {
	let response = await caches.match(request);
	if (!response) {
		response = await fetch(request);

		const cache = await caches.open(CACHE_NAME);
		console.log('[SW] Cached ' + request.url);
		cache.put(request, response.clone());
	}

	return response;
}

self.addEventListener('fetch', async e => {
	if (e.request.method !== 'GET' || e.request.headers.has('range')) return;

	const url = new URL(e.request.url);
	// Skip non-HTTP URIs and different origins
	if (!url.protocol.startsWith('http') || url.host != self.location.host) return;

	if (ASSETS.includes(url.pathname)) {
		e.respondWith(requestCached(e.request));
	}
});
